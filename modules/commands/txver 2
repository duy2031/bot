module.exports.config = {
  name: "taixiu2",
  version: "1.0.0",
  hasPermssion: 0,
  credits: "DuyVuongUwU (fix by ChatGPT)",
  description: "Tài xỉu nhưng nhiều người chơi!",
  commandCategory: "Game",
  usages: "[new/leave/start/end]",
  cooldowns: 5
};

module.exports.languages = {
  "vi": {
    "moneyEror": "⚠ Số tiền cược không hợp lệ!",
    "moneyMin": "⚠ Số tiền cược phải lớn hơn hoặc bằng 500đ!",
    "moneyDeCreate": "⚠ Bạn không đủ %1$ để tạo bàn game!",
    "gameCreated": "⚠ Nhóm này đã có bàn game!",
    "createSuccess": "🥳 Đã tạo bàn chơi!\nSố tiền cược: %1$\nHiện có 1 người chơi.\nDùng %2 start để bắt đầu, %3 end để kết thúc, %4 join để tham gia!",
    "notCreatedYet": "⚠ Nhóm này chưa có bàn game!",
    "gameStarted": "⚠ Bàn game này đã bắt đầu!",
    "moneyDeJoin": "⚠ Bạn không đủ %1$ để tham gia!",
    "joined": "⚠ Bạn đã tham gia bàn game!",
    "joinSuccess": "🥳 Tham gia thành công! Hiện có %1 người chơi.",
    "userNotInGame": "⚠ Bạn không có trong bàn game!",
    "leaveFail": "⚠ Bàn game đã bắt đầu, không thể rời!",
    "leaveSuccess": "🥺 Bạn đã rời bàn game.",
    "countPlayer": "🥺 %1 đã rời bàn, hiện còn %2 người.",
    "authorLeave": "🥺 %1 đã rời, bàn game đã giải tán!",
    "startFail": "⚠ Bạn không phải chủ bàn game!",
    "notEnoughMembers": "⚠ Không đủ người để bắt đầu!",
    "startPlaying": "🔊 GAME START: Có %1 người! Nhắn 'tài' hoặc 'xỉu' để chọn!",
    "endFail": "⚠ Bạn không phải chủ bàn game!",
    "endSuccess": "🎆 Đã kết thúc bàn game!",
    "tutorial": "⚠ Cách dùng:\n- create/new/-c: Tạo bàn\n- join/-j: Tham gia\n- leave/-l: Rời bàn\n- start/-s: Bắt đầu\n- end/-e: Kết thúc",
    "error": "⚠ Lỗi module: %1"
  }
};

module.exports.handleEvent = async function ({ api, event, Currencies }) {
  const { threadID, messageID, body, senderID } = event;
  if (!body) return;

  const typ = ["tài", "xỉu"];
  const random = typ[Math.floor(Math.random() * typ.length)];
  const gameThread = global.taixiuS?.get(threadID);

  if (!gameThread || !gameThread.start) return;

  if (body.toLowerCase() == "tài" || body.toLowerCase() == "xỉu") {
    const player = gameThread.player.find(p => p.userID == senderID);
    if (!player) return;

    if (player.choose.status) {
      return api.sendMessage("⚠ Bạn đã chọn rồi!", threadID, messageID);
    }

    player.choose = { status: true, msg: body.toLowerCase() };
    api.sendMessage(`👤 ${player.name} đã chọn ${body.toUpperCase()}!`, threadID, messageID);

    const allChosen = gameThread.player.every(p => p.choose.status);
    if (allChosen) {
      api.sendMessage("🥳 Đang lắc....", threadID, async (err, data) => {
        if (err) return;
        setTimeout(async () => {
          api.unsendMessage(data.messageID);
          const ketqua = random;
          const win = [];
          const lose = [];

          gameThread.player.forEach(p => {
            if (p.choose.msg == ketqua) win.push(p);
            else lose.push(p);
          });

          let msg = `💎 KẾT QUẢ: ${ketqua.toUpperCase()}\n\n🥳 Người thắng:\n`;
          for (let i = 0; i < win.length; i++) {
            const user = win[i];
            const data = await Currencies.getData(user.userID);
            data.money += gameThread.money * 3;
            await Currencies.setData(user.userID, { data });
            msg += `${i + 1}. ${user.name}\n`;
          }

          if (lose.length > 0) {
            msg += "\n🥺 Người thua:\n";
            for (let i = 0; i < lose.length; i++) {
              const user = lose[i];
              const data = await Currencies.getData(user.userID);
              data.money -= gameThread.money;
              await Currencies.setData(user.userID, { data });
              msg += `${i + 1}. ${user.name}\n`;
            }
          }

          msg += `\n🎁 Mỗi người thắng nhận: ${gameThread.money * 3}$\n💰 Mỗi người thua mất: ${gameThread.money}$`;

          global.taixiuS.delete(threadID);
          api.sendMessage(msg, threadID);
        }, 5000);
      });
    }
  }
};

module.exports.run = async function ({ api, event, args, Users, Currencies, getText }) {
  try {
    if (!global.taixiuS) global.taixiuS = new Map();
    const { threadID, messageID, senderID } = event;
    let gameThread = global.taixiuS.get(threadID);

    switch (args[0]) {
      case "create":
      case "new":
      case "-c": {
        if (!args[1] || isNaN(args[1])) return api.sendMessage(getText("moneyEror"), threadID, messageID);
        const money = parseInt(args[1]);
        if (money < 50) return api.sendMessage(getText("moneyMin"), threadID, messageID);

        const userMoney = (await Currencies.getData(senderID)).money || 0;
        if (userMoney < money) return api.sendMessage(getText("moneyDeCreate", money), threadID, messageID);

        if (gameThread) return api.sendMessage(getText("gameCreated"), threadID, messageID);

        const name = await Users.getNameUser(senderID);
        global.taixiuS.set(threadID, {
          box: threadID,
          start: false,
          author: senderID,
          player: [{ name, userID: senderID, choose: { status: false, msg: null } }],
          money
        });
        return api.sendMessage(getText("createSuccess", money, global.config.PREFIX + this.config.name, global.config.PREFIX + this.config.name, global.config.PREFIX + this.config.name), threadID);
      }

      case "join":
      case "-j": {
        if (!gameThread) return api.sendMessage(getText("notCreatedYet"), threadID, messageID);
        if (gameThread.start) return api.sendMessage(getText("gameStarted"), threadID, messageID);

        const userMoney = (await Currencies.getData(senderID)).money || 0;
        if (userMoney < gameThread.money) return api.sendMessage(getText("moneyDeJoin", gameThread.money), threadID, messageID);

        if (gameThread.player.some(p => p.userID == senderID)) return api.sendMessage(getText("joined"), threadID, messageID);

        const name = await Users.getNameUser(senderID);
        gameThread.player.push({ name, userID: senderID, choose: { status: false, msg: null } });
        global.taixiuS.set(threadID, gameThread);
        return api.sendMessage(getText("joinSuccess", gameThread.player.length), threadID, messageID);
      }

      case "leave":
      case "-l": {
        if (!gameThread) return api.sendMessage(getText("notCreatedYet"), threadID, messageID);
        const index = gameThread.player.findIndex(p => p.userID == senderID);
        if (index === -1) return api.sendMessage(getText("userNotInGame"), threadID, messageID);
        if (gameThread.start) return api.sendMessage(getText("leaveFail"), threadID, messageID);

        if (gameThread.author == senderID) {
          global.taixiuS.delete(threadID);
          const name = await Users.getNameUser(senderID);
          return api.sendMessage(getText("authorLeave", name), threadID, messageID);
        } else {
          const name = gameThread.player[index].name;
          gameThread.player.splice(index, 1);
          global.taixiuS.set(threadID, gameThread);
          api.sendMessage(getText("leaveSuccess"), threadID, messageID);
          return api.sendMessage(getText("countPlayer", name, gameThread.player.length), threadID);
        }
      }

      case "start":
      case "-s": {
        if (!gameThread) return api.sendMessage(getText("notCreatedYet"), threadID, messageID);
        if (gameThread.author != senderID) return api.sendMessage(getText("startFail"), threadID, messageID);
        if (gameThread.player.length <= 1) return api.sendMessage(getText("notEnoughMembers"), threadID, messageID);
        if (gameThread.start) return api.sendMessage(getText("gameStarted"), threadID, messageID);

        gameThread.start = true;
        global.taixiuS.set(threadID, gameThread);
        return api.sendMessage(getText("startPlaying", gameThread.player.length), threadID);
      }

      case "end":
      case "-e": {
        if (!gameThread) return api.sendMessage(getText("notCreatedYet"), threadID, messageID);
        if (gameThread.author != senderID) return api.sendMessage(getText("endFail"), threadID, messageID);

        global.taixiuS.delete(threadID);
        return api.sendMessage(getText("endSuccess"), threadID, messageID);
      }

      default:
        return api.sendMessage(getText("tutorial"), threadID, messageID);
    }
  } catch (err) {
    return api.sendMessage(getText("error", err), event.threadID, event.messageID);
  }
};

